import puts, fork, exit, wait, kill, getpid, sched_yield,
	pipe, dup2, execlp, close, read, write,
	access, chdir, chmod, creat, remove,
	setuid, setgid;
import pthread_* from "libpthread.so.0";

import List from "ptrslibs/list.ptrs";
import SocketSet from "ptrslibs/socket.ptrs";
import setTimeout, clearTimeout from "ptrslibs/timeout.ptrs";

const MAX_TIME = 3000;
const PATH = "/home/play";
const GROUP_ID = 1000;
const USER_ID = 1000;

const R_OK = 4;
const SIGKILL = 9;

struct pipearg
{
	readfd : int;
	writefd : int;
};

struct RunningProcess
{
	id;
	pid;
	pipefd;
	timeout;

	constructor(_id, _pid, _pipefd, _timeout)
	{
		id = _id;
		pid = _pid;
		pipefd = _pipefd;
		timeout = _timeout;
	}
};

var buff{4096};
var lock{64};
var fdset;
var procs;

function waiter(sendfd)
{
	while(true)
	{
		var pid = wait!i32(NULL);
		if(pid < 0)
			return;

		pthread_mutex_lock(lock);

		var proc = procs.find((p) -> p.pid == pid);

		var len;
		while((len = read!ssize(proc.pipefd, buff, 4095)) > 0)
		{
			write(sendfd, &proc.id, sizeof(pointer));
			write(sendfd, buff, len);
		}

		fdset.remove(proc.pipefd);
		close(proc.pipefd);
		remove("$PATH/play$pid.ptrs");

		write(sendfd, &proc.id, sizeof(pointer));
		write(sendfd, "ready", 5);

		procs.remove(proc);
		delete proc;

		pthread_mutex_unlock(lock);
	}
}

function timeoutProc(pid)
{
	kill(-pid, SIGKILL);
	kill(pid, SIGKILL);
}

function watchdog(sendfd, receivefd)
{
	pthread_mutex_init(lock, NULL);
	pthread_mutex_lock(lock);

	var thread = 0;
	fdset = new SocketSet();
	procs = new List();
	fdset.add(receivefd);

	while(true) scoped
	{
		pthread_mutex_unlock(lock);

		var fd;
		try fd = fdset.check();

		pthread_mutex_lock(lock);

		if(!fd)
			continue;

		if(fd == receivefd)
		{
			var id = 0;
			if(read!ssize(receivefd, &id, sizeof(pointer)) != sizeof(pointer))
				throw "read error";

			var len = read!ssize(receivefd, buff, 4096);
			if(len <= 0)
				throw "read error";

			if(procs.find((p) -> p.id == id))
				continue;

			var pipes : pipearg();
			pipe(pipes);

			var pid = fork!i32();
			if(pid == 0)
			{
				pid = getpid();

				close(pipes.readfd);
				dup2(pipes.writefd, 1);
				dup2(pipes.writefd, 2);

				if(setgid!int(GROUP_ID) != 0 || setuid!int(USER_ID) != 0)
					throw "setgid/setuid failed";

				chdir(PATH);
				var file = "$PATH/play$pid.ptrs";

				while(access!int(file, R_OK) != 0)
					sched_yield();

				execlp("ptrs", "ptrs", file, NULL);

				puts("execlp failed");
				exit(1);
			}
			else
			{
				close(pipes.writefd);

				var file = "$PATH/play$pid.ptrs";
				fd = creat(file, 0600); //rw- --- ---
				write(fd, buff, len);
				close(fd);

				if(procs.length == 0)
					pthread_create(&thread, NULL, waiter, sendfd);

				var job = setTimeout(timeoutProc, MAX_TIME, pid);
				procs.add(new RunningProcess(id, pid, pipes.readfd, job));
				fdset.add(pipes.readfd);

				write(sendfd, &id, sizeof(pointer));
				write(sendfd, "running", 7);
				chmod(file, 0644); //rw- r-- r--
			}
		}
		else
		{
			var proc = procs.find((p) -> p.pipefd == fd);

			var count = read!ssize(fd, buff, 4095);
			if(count <= 0)
				throw "read error";

			write(sendfd, &proc.id, sizeof(pointer));
			write(sendfd, buff, count);
		}
	}
}
